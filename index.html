<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Nick Levantis | Music</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-91NQ6H9GNK"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-91NQ6H9GNK")</script><style>*{margin:0;padding:0;box-sizing:border-box}:root{--bg-color:#0a0a0a;--text-color:#ffffff;--secondary-text:#aaaaaa;--accent-color:#ffffff;--ui-bg:rgba(255, 255, 255, 0.05);--ui-bg-hover:rgba(255, 255, 255, 0.1);--player-bg:rgba(255, 255, 255, 0.03);--player-border:rgba(255, 255, 255, 0.05);--progress-bg:rgba(255, 255, 255, 0.1);--overlay-bg:rgba(0, 0, 0, 0.7);--circle-bg:#000000;--strand-base:255,255,255}body.light-mode{--bg-color:#f5f5f5;--text-color:#000000;--secondary-text:#555555;--accent-color:#000000;--ui-bg:rgba(0, 0, 0, 0.05);--ui-bg-hover:rgba(0, 0, 0, 0.1);--player-bg:rgba(0, 0, 0, 0.03);--player-border:rgba(0, 0, 0, 0.05);--progress-bg:rgba(0, 0, 0, 0.1);--overlay-bg:rgba(255, 255, 255, 0.7);--circle-bg:#ffffff;--strand-base:0,0,0}body{background-color:var(--bg-color);color:var(--text-color);font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;overflow:hidden;min-height:100vh;position:relative;display:flex;flex-direction:column;transition:background-color .5s ease,color .5s ease}#glcanvas{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0}.container{max-width:100%;margin:0;padding:0;position:relative;z-index:2;flex:1;display:flex;flex-direction:column;height:100vh}header{display:flex;justify-content:space-between;align-items:center;width:100%;padding:25px 30px;position:absolute;top:0;left:0;z-index:20}.header-left{display:flex;flex-direction:column;align-items:flex-start}.site-title{font-size:1.1rem;font-weight:400;letter-spacing:4px;text-transform:uppercase;color:var(--text-color);transition:color .5s ease;line-height:1}.subtitle{font-size:.8rem;font-weight:300;letter-spacing:3px;color:var(--secondary-text);transition:color .5s ease;margin-top:5px;line-height:1}.header-controls{display:flex;gap:12px;align-items:center}.about-btn,.theme-toggle{background:0 0;border:none;width:42px;height:42px;display:flex;justify-content:center;align-items:center;color:var(--text-color);cursor:pointer;transition:all .3s ease;font-size:1.1rem}.about-btn:hover,.theme-toggle:hover{transform:scale(1.1)}.center-player{position:fixed;bottom:70px;left:50%;transform:translateX(-50%);z-index:10;display:flex;flex-direction:column;align-items:center;gap:5px}.player-controls{display:flex;align-items:center;gap:10px}.control-btn{background:0 0;border:none;width:50px;height:50px;display:flex;justify-content:center;align-items:center;color:var(--text-color);cursor:pointer;transition:all .3s ease;font-size:1.3rem}.control-btn:hover{transform:scale(1.1)}.play-btn{width:60px;height:60px;font-size:1.6rem}.player-info{display:flex;flex-direction:column;align-items:center;gap:8px;text-align:center}.track-title{font-size:1.2rem;font-weight:500;color:var(--text-color);line-height:1}.track-description{font-size:.7rem;color:var(--secondary-text)}.progress-container{width:250px;height:2px;background:var(--progress-bg);cursor:pointer}.progress-bar{height:100%;width:0%;background:var(--text-color);transition:width .1s}.about-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:var(--overlay-bg);backdrop-filter:blur(5px);display:flex;justify-content:center;align-items:center;z-index:1000;opacity:0;visibility:hidden;transition:all .5s ease}.about-overlay.active{opacity:1;visibility:visible}.about-content{background:0 0;border:none;padding:3rem;width:450px;height:auto;transform:scale(.8) translateY(50px);opacity:0;transition:all .5s ease .2s;position:relative;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center}.about-overlay.active .about-content{transform:scale(1) translateY(0);opacity:1}.close-btn{position:absolute;top:20px;right:20px;background:0 0;border:none;width:40px;height:40px;display:flex;justify-content:center;align-items:center;color:var(--text-color);cursor:pointer;transition:all .3s ease;font-size:1.2rem;z-index:10}.close-btn:hover{transform:scale(1.1)}.about-title{font-size:1.8rem;font-weight:300;margin-bottom:1.5rem;color:var(--text-color)}.about-text{font-size:1rem;line-height:1.6;color:var(--text-color);margin-bottom:2rem;max-width:350px}.social-links{display:flex;justify-content:center;gap:1.5rem;margin-top:1.5rem}.social-link{background:0 0;border:none;width:45px;height:45px;display:flex;justify-content:center;align-items:center;color:var(--text-color);text-decoration:none;transition:all .3s ease;font-size:1.2rem}.social-link:hover{transform:translateY(-3px)}.theme-toggle i{transition:transform .5s ease}body.light-mode .theme-toggle .fa-moon{display:none}body.light-mode .theme-toggle .fa-sun{display:block}.theme-toggle .fa-sun{display:none}body.light-mode .theme-toggle .fa-sun{display:block}body.light-mode .theme-toggle .fa-moon{display:none}@media (max-width:768px){header{padding:20px 25px}.site-title{font-size:1rem;letter-spacing:3px}.subtitle{font-size:.8rem}.center-player{bottom:30px;gap:12px}.player-controls{gap:15px}.control-btn{width:45px;height:45px;font-size:1.1rem}.play-btn{width:55px;height:55px;font-size:1.4rem}.track-title{font-size:1.2rem}.progress-container{width:200px}.about-content{width:350px;padding:2.5rem}.about-title{font-size:1.6rem}.about-text{font-size:.95rem;max-width:280px}}@media (max-width:480px){header{padding:15px 20px}.header-left{align-items:center}.site-title{font-size:.9rem}.subtitle{font-size:.75rem;text-align:center}.center-player{bottom:25px;gap:10px}.player-controls{gap:12px}.control-btn{width:40px;height:40px;font-size:1rem}.play-btn{width:50px;height:50px;font-size:1.2rem}.track-title{font-size:1.1rem}.track-description{font-size:.8rem}.progress-container{width:180px}.about-content{width:300px;padding:2rem}.about-title{font-size:1.4rem}.about-text{font-size:.9rem;max-width:240px}}</style></head><body><canvas id="glcanvas"></canvas><div class="container"><header><div class="header-left"><div class="site-title">NICK LEVANTIS</div><div class="subtitle">LANIAKEA SESSIONS</div></div><div class="header-controls"><button class="theme-toggle" id="theme-toggle"><i class="fas fa-moon"></i><i class="fas fa-sun"></i></button><button class="about-btn" id="about-btn"><i class="fas fa-info"></i></button></div></header><div class="center-player"><div class="player-controls"><button class="control-btn" id="prev-btn"><i class="fas fa-step-backward"></i></button><button class="control-btn play-btn" id="play-btn"><i class="fas fa-play"></i></button><button class="control-btn" id="next-btn"><i class="fas fa-step-forward"></i></button></div><div class="player-info"><div class="track-title" id="current-track-title">Fragments</div><div class="track-description" id="current-track-description">Experimental melodic fragments</div><div class="progress-container" id="progress-container"><div class="progress-bar" id="progress-bar"></div></div></div></div></div><div class="about-overlay" id="about-overlay"><div class="about-content"><button class="close-btn" id="close-btn"><i class="fas fa-times"></i></button><div class="about-text"><p>Sound artist from Piraeus exploring electronic textures, live coding, and experimental minimal sonic forms.</p></div><div class="social-links"><a href="https://soundcloud.com/nicklevantis" class="social-link" target="_blank"><i class="fab fa-soundcloud"></i></a><a href="https://youtube.com/nicklevantis" class="social-link" target="_blank"><i class="fab fa-youtube"></i></a><a href="https://nicklevantis.svbtle.com" class="social-link" target="_blank"><i class="fas fa-pen-nib"></i></a></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script><script>// Audio context and elements
        let audioContext;
        let audioElement;
        let analyser;
        let source;
        let isPlaying = false;
        let currentTrackIndex = 0;
        let audioData = new Uint8Array(256);
        let preloadedAudio = null; // For preloading next track
        
        // Track data with your audio URLs
        const tracks = [
            {
                id: 1,
                title: "Fragments",
                description: "Experimental melodic fragments",
                url: "https://nicklevantis.com/audio/fragments.mp3",
                duration: 180
            },
            {
                id: 2,
                title: "Nowhere",
                description: "Dystopian noisy soundscape",
                url: "https://nicklevantis.com/audio/nowhere.mp3",
                duration: 240
            },
            {
                id: 3,
                title: "Broken",
                description: "Live coding exploration",
                url: "https://nicklevantis.com/audio/broken.mp3",
                duration: 210
            },
            {
                id: 4,
                title: "Romance",
                description: "Sounds from the past",
                url: "https://nicklevantis.com/audio/romance.mp3",
                duration: 195
            }
        ];
        
        // Initialize audio context
        function initAudio() {
            if (audioContext) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioElement = new Audio();
                audioElement.crossOrigin = "anonymous";
                audioElement.volume = 0.7;
                
                // Create analyser node
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.8;
                
                // Connect audio element to analyser
                source = audioContext.createMediaElementSource(audioElement);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                
                // Set up progress bar
                audioElement.addEventListener('timeupdate', updateProgressBar);
                audioElement.addEventListener('ended', handleTrackEnd);
                
                // Load the first track
                loadTrack(currentTrackIndex);
                
                console.log("Audio initialized successfully");
            } catch (error) {
                console.error("Error initializing audio:", error);
            }
        }
        
        // Load a track
        function loadTrack(trackIndex) {
            const track = tracks[trackIndex];
            audioElement.src = track.url;
            document.getElementById('current-track-title').textContent = track.title;
            document.getElementById('current-track-description').textContent = track.description;
            
            // Reset progress bar
            document.getElementById('progress-bar').style.width = '0%';
            
            // Preload the audio
            audioElement.load();
            
            // Preload next track
            preloadNextTrack(trackIndex);
        }
        
        // Preload the next track for seamless playback
        function preloadNextTrack(currentTrackIndex) {
            const nextTrackIndex = (currentTrackIndex + 1) % tracks.length;
            const nextTrack = tracks[nextTrackIndex];
            
            // If we already have a preloaded audio element, clean it up
            if (preloadedAudio) {
                preloadedAudio.src = '';
                preloadedAudio = null;
            }
            
            // Create and preload next track
            preloadedAudio = new Audio();
            preloadedAudio.src = nextTrack.url;
            preloadedAudio.preload = 'auto';
            preloadedAudio.load();
            
            console.log(`Preloaded next track: ${nextTrack.title}`);
        }
        
        // Update reactive text colors based on audio intensity
        function updateReactiveColors(intensity) {
            const colorValue = Math.floor(255 * Math.pow((1 - intensity), 2));
            
            // Apply to text elements
            const trackTitle = document.getElementById('current-track-title');
            const trackDesc = document.getElementById('current-track-description');
            const controlBtns = document.querySelectorAll('.control-btn');
            const progressBar = document.getElementById('progress-bar');
            const progressContainer = document.getElementById('progress-container');
            
            // For dark theme - lighter with more intensity, for light theme - darker with more intensity
            const isLightMode = document.body.classList.contains('light-mode');
            const invertedColorValue = isLightMode ? 255 - colorValue : colorValue;
            
            if (trackTitle) trackTitle.style.color = `rgb(${invertedColorValue}, ${invertedColorValue}, ${invertedColorValue})`;
            if (trackDesc) trackDesc.style.color = `rgb(${invertedColorValue}, ${invertedColorValue}, ${invertedColorValue})`;
            
            // Make control buttons reactive
            controlBtns.forEach(btn => {
                btn.style.color = `rgb(${invertedColorValue}, ${invertedColorValue}, ${invertedColorValue})`;
            });
            
            // Make progress bar reactive
            if (progressBar) {
                progressBar.style.background = `rgb(${invertedColorValue}, ${invertedColorValue}, ${invertedColorValue})`;
            }
            
            // Make progress container reactive
            if (progressContainer) {
                progressContainer.style.background = `rgba(${invertedColorValue}, ${invertedColorValue}, ${invertedColorValue}, 0.2)`;
            }
        }
        
        // Play/pause track functionality
        async function togglePlay() {
            // Initialize audio if not already done
            initAudio();
            
            // If audio context is suspended, resume it
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            // Toggle play/pause
            if (isPlaying) {
                audioElement.pause();
                isPlaying = false;
                updatePlayButton(false);
            } else {
                try {
                    await audioElement.play();
                    isPlaying = true;
                    updatePlayButton(true);
                    console.log("Audio playback started successfully");
                } catch (error) {
                    console.error("Error playing audio:", error);
                }
            }
        }
        
        // Change track functionality
        async function changeTrack(direction) {
            // Initialize audio if not already done
            initAudio();
            
            // Stop current track if playing
            if (isPlaying) {
                audioElement.pause();
                isPlaying = false;
            }
            
            // Calculate new track index
            if (direction === 'next') {
                currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
            } else {
                currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
            }
            
            // Load new track
            loadTrack(currentTrackIndex);
            
            // Play the track if it was playing before
            if (isPlaying) {
                try {
                    await audioElement.play();
                    isPlaying = true;
                    updatePlayButton(true);
                } catch (error) {
                    console.error("Error playing audio:", error);
                }
            }
        }
        
        // Update play button appearance
        function updatePlayButton(playing) {
            const mainPlayBtn = document.getElementById('play-btn');
            
            if (playing) {
                mainPlayBtn.innerHTML = '<i class="fas fa-pause"></i>';
            } else {
                mainPlayBtn.innerHTML = '<i class="fas fa-play"></i>';
            }
        }
        
        // Update progress bar
        function updateProgressBar() {
            if (!audioElement) return;
            
            const progress = (audioElement.currentTime / audioElement.duration) * 100;
            const progressBar = document.getElementById('progress-bar');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }
        
        // Handle track end
        function handleTrackEnd() {
            isPlaying = false;
            updatePlayButton(false);
            
            // Auto-play next track
            changeTrack('next');
        }
        
        // Set theme based on local time
        function setThemeByTime() {
            const hour = new Date().getHours();
            const isDayTime = hour >= 6 && hour < 18; // 6 AM to 6 PM is considered daytime
            
            // Check if user has a saved preference first
            const savedTheme = localStorage.getItem('theme');
            
            if (!savedTheme) {
                // Only set by time if no user preference is saved
                if (isDayTime) {
                    document.body.classList.add('light-mode');
                } else {
                    document.body.classList.remove('light-mode');
                }
            }
        }
        
        // Toggle theme function
        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            
            // Save preference to localStorage
            const isLightMode = document.body.classList.contains('light-mode');
            localStorage.setItem('theme', isLightMode ? 'light' : 'dark');
        }
        
        // Set up event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Set theme based on time of day
            setThemeByTime();
            
            // Initialize audio immediately
            initAudio();
            
            // Check for saved theme preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
            
            document.getElementById('play-btn').addEventListener('click', togglePlay);
            
            document.getElementById('prev-btn').addEventListener('click', function() {
                changeTrack('prev');
            });
            
            document.getElementById('next-btn').addEventListener('click', function() {
                changeTrack('next');
            });
            
            document.getElementById('progress-container').addEventListener('click', function(e) {
                if (!audioElement) return;
                
                const rect = this.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const width = rect.width;
                const percentage = clickX / width;
                
                audioElement.currentTime = percentage * audioElement.duration;
            });
            
            // Theme toggle functionality
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
            
            // About popup functionality
            const aboutBtn = document.getElementById('about-btn');
            const aboutOverlay = document.getElementById('about-overlay');
            const closeBtn = document.getElementById('close-btn');
            
            aboutBtn.addEventListener('click', function() {
                aboutOverlay.classList.add('active');
            });
            
            closeBtn.addEventListener('click', function() {
                aboutOverlay.classList.remove('active');
            });
            
            aboutOverlay.addEventListener('click', function(e) {
                if (e.target === aboutOverlay) {
                    aboutOverlay.classList.remove('active');
                }
            });
            
            // Initialize WebGL visualization
            initWebGLVisualization();
        });
        
        /* ===== Audio Reactive WebGL Strands ===== */
        function initWebGLVisualization() {
            const canvas = document.getElementById("glcanvas");
            const gl = canvas.getContext("webgl2", {alpha:false});
            let W=0,H=0;

            function resize(){
                W = canvas.width = window.innerWidth * window.devicePixelRatio;
                H = canvas.height = window.innerHeight * window.devicePixelRatio;
                gl.viewport(0,0,W,H);
            }
            resize();
            window.addEventListener("resize",resize);

            const vs = `#version 300 es
            in vec2 a;
            in vec4 c;
            out vec4 vc;
            uniform vec2 r;
            void main(){
                vec2 p=a/r*2.0-1.0;
                gl_Position=vec4(p.x,-p.y,0,1);
                vc=c;
            }`;
            const fs = `#version 300 es
            precision highp float;
            in vec4 vc;
            out vec4 o;
            void main(){o=vc;}
            `;

            function sh(type,src){
                let s=gl.createShader(type);
                gl.shaderSource(s,src);
                gl.compileShader(s);
                if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
                    console.log(gl.getShaderInfoLog(s));
                return s;
            }
            const prog = gl.createProgram();
            gl.attachShader(prog,sh(gl.VERTEX_SHADER,vs));
            gl.attachShader(prog,sh(gl.FRAGMENT_SHADER,fs));
            gl.linkProgram(prog);
            gl.useProgram(prog);

            const posB = gl.createBuffer();
            const colB = gl.createBuffer();
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            let lp = gl.getAttribLocation(prog,"a");
            let lc = gl.getAttribLocation(prog,"c");
            gl.bindBuffer(gl.ARRAY_BUFFER,posB);
            gl.enableVertexAttribArray(lp);
            gl.vertexAttribPointer(lp,2,gl.FLOAT,false,0,0);
            gl.bindBuffer(gl.ARRAY_BUFFER,colB);
            gl.enableVertexAttribArray(lc);
            gl.vertexAttribPointer(lc,4,gl.FLOAT,false,0,0);

            let ur = gl.getUniformLocation(prog,"r");

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

            const N = 140;
            const S = 80;
            let strands=[];
            for(let i=0;i<N;i++){
                strands.push({
                    ang:(i/N)*Math.PI*2,
                    s1:0.3+Math.random()*0.2,
                    s2:0.02+Math.random()*0.02,
                    seed:Math.random()*1000,
                    // Audio reactive properties
                    bassMultiplier: 0.5 + Math.random() * 1.5,
                    midMultiplier: 0.5 + Math.random() * 1.5,
                    highMultiplier: 0.5 + Math.random() * 1.5
                });
            }

            let t=0;
            function draw(){
                requestAnimationFrame(draw);

                const light = document.body.classList.contains("light-mode");
                gl.clearColor(light?1:0.03, light?1:0.03, light?1:0.04,1);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Get audio data and calculate frequency bands
                let bassLevel = 0, midLevel = 0, highLevel = 0;
                if (analyser && isPlaying) {
                    analyser.getByteFrequencyData(audioData);
                    
                    // Split frequency spectrum into bass, mid, high
                    const bassRange = Math.floor(audioData.length * 0.1);
                    const midRange = Math.floor(audioData.length * 0.5);
                    const highRange = Math.floor(audioData.length * 0.9);
                    
                    for (let i = 0; i < audioData.length; i++) {
                        if (i < bassRange) bassLevel += audioData[i];
                        else if (i < midRange) midLevel += audioData[i];
                        else if (i < highRange) highLevel += audioData[i];
                    }
                    
                    bassLevel /= bassRange;
                    midLevel /= (midRange - bassRange);
                    highLevel /= (highRange - midRange);
                    
                    // Normalize to 0-1 range
                    bassLevel /= 255;
                    midLevel /= 255;
                    highLevel /= 255;
                } else {
                    // Subtle movement when no audio is playing
                    const time = Date.now() * 0.001;
                    bassLevel = Math.sin(time * 0.5) * 0.1 + 0.1;
                    midLevel = Math.sin(time * 0.7) * 0.1 + 0.1;
                    highLevel = Math.sin(time * 0.9) * 0.1 + 0.1;
                }

                // Update reactive colors based on audio
                const overallIntensity = (bassLevel + midLevel + highLevel) / 3;
                updateReactiveColors(overallIntensity);

                let cx=W/2, cy=H/2, R=Math.min(W,H)*0.4;
                let pos = [], col=[];

                for(let i=0;i<N;i++){
                    let st = strands[i];
                    for(let j=0;j<S;j++){
                        let p=j/(S-1);
                        let r=R*p;
                        
                        // Audio-reactive movement
                        const bassEffect = bassLevel * st.bassMultiplier;
                        const midEffect = midLevel * st.midMultiplier;
                        const highEffect = highLevel * st.highMultiplier;
                        
                        let slow=Math.sin(t*0.005+st.seed)*st.s1*0.3 * (1 + bassEffect * 2);
                        let micro=Math.sin(t*st.s2+j*0.1+st.seed)*0.08 * (1 + midEffect * 3);
                        let highFreq=Math.sin(t*0.02+j*0.05+st.seed)*0.04 * (1 + highEffect * 4);
                        
                        let a=st.ang + (slow + micro + highFreq)*p;

                        let x=cx+Math.cos(a)*r;
                        let y=cy+Math.sin(a)*r;

                        // Audio-reactive thickness
                        let th = (1-p)*0.9*(window.devicePixelRatio*0.7) * (1 + overallIntensity * 0.8);
                        let ox=Math.cos(a+Math.PI/2)*th;
                        let oy=Math.sin(a+Math.PI/2)*th;

                        pos.push(x-ox,y-oy, x+ox,y+oy);

                        // Audio-reactive colors
                        const light = document.body.classList.contains("light-mode");
                        let Rc, Gc, Bc;
                        
                        if (isPlaying) {
                            // Dynamic colors based on frequency bands
                            if (light) {
                                Rc = 0.1 + bassLevel * 0.4;
                                Gc = 0.1 + midLevel * 0.4;
                                Bc = 0.1 + highLevel * 0.4;
                            } else {
                                Rc = 0.6 + bassLevel * 0.4;
                                Gc = 0.7 + midLevel * 0.3;
                                Bc = 0.8 + highLevel * 0.2;
                            }
                        } else {
                            // Default colors when no audio
                            if (light) {
                                Rc = 0;
                                Gc = 0;
                                Bc = 0;
                            } else {
                                Rc = 0.9;
                                Gc = 0.95;
                                Bc = 1.0;
                            }
                        }
                        
                        // Audio-reactive alpha
                        let A = 0.35*(1-p) * (1 + overallIntensity * 0.5);
                        col.push(Rc,Gc,Bc,A, Rc,Gc,Bc,A);
                    }
                }

                gl.bindBuffer(gl.ARRAY_BUFFER,posB);
                gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(pos),gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER,colB);
                gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(col),gl.DYNAMIC_DRAW);

                gl.useProgram(prog);
                gl.uniform2f(ur,W,H);

                let offset=0, count=S*2;
                for(let i=0;i<N;i++){
                    gl.drawArrays(gl.TRIANGLE_STRIP, offset, count);
                    offset+=count;
                }

                t+=1;
            }
            draw();
        }</script></body></html>
